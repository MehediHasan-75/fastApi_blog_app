# First we need to understand `app = FastAPI()` in `main.py`

* `uvicorn main:app --reload` here main = file name and app = FastAPI instance
* if the instance name = myapp the command will be `uvicorn main:myapp --reload`
* if the file name = mehedi the command will be `uvicorn mehedi:app --reload`

# Second is that the function name under the decorator does not matter. we can use the same function name for different decorators.

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def home():
    return {"data": "this is from / path"}

@app.get("/about")
def about():
    return {"data": "this is from /about path"}
```

* so only decorator matters for routing

# Third, `@app.get('/about')`  here,

* @app = @instance
* get() = operation on path
* '/about' called path on FastAPI (router on other frameworks)

# Fourth, `def abc():` is called a path operation function in which above we are defining the operation on the path.

* this is the operation/operations we are going to perform on the route.

# Fifth, Dynamic route

* for dynamic routing use `/{}` and `need to accept this variable` in `the path operation function`.

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/blog/{id}")
def show(id):
    return {"data": id}
```

* If we hit `http://127.0.0.1:8000/blog/unpublished`, the output will look like `{"data": "unpublished"}`. But, we need id as `integer`
* Here comes type hints. this will `convert compatible type into the target type`. in this case, `a string of number in string`.

```python
@app.get('/blog/{id}')
def show(id: int):
    return {'data': id}
```

* But, if they are not compatible. it will show

```json
{
  "detail": [
    {
      "type": "int_parsing",
      "loc": [
        "path",
        "id"
      ],
      "msg": "Input should be a valid integer, unable to parse string as an integer",
      "input": "unpublished"
    }
  ]
}
```

# Sixth, fast api reads code line by line

```python
from fastapi import FastAPI

app = FastAPI()

@app.get('/blog/{id}')
def show(id:int):
    return {'data': id}

@app.get('/blog/unpublished')
def unpublished():
    return {'data': 'all unpublished blogs'}
```

* if we hit `http://127.0.0.1:8000/blog/unpublished` this will show. because fast api reads file line by line and go to show() method.

```json
{
  "detail": [
    {
      "type": "int_parsing",
      "loc": [
        "path",
        "id"
      ],
      "msg": "Input should be a valid integer, unable to parse string as an integer",
      "input": "unpublished"
    }
  ]
}
```

* solution = whenever you create a dynamic route you have to take care of routes which match with the route and move them before the dynamic route

```python
from fastapi import FastAPI

app = FastAPI()

@app.get('/blog/unpublished')
def unpublished():
    return {'data': 'all unpublished blogs'}

@app.get('/blog/{id}')
def show(id:int):
    return {'data': id}
```

N.B : All the data validation is performed under the hood by Pydantic, so you will get all the benefits from it.

# Api docs, for this see `localhost:8000/docs` or `localhost:8000/redoc`

# Seventh, query parameters

* Suppose that we have a million of blogs, and you need a specific one. In this case we can send query parameters with url from client.
* For example, for only the then published blogs `/blog?limit=10&published=true`
* In, this case we need to accept the query parameters also in the path operation function like a path parameter.

```python
@app.get('/blog')
def index(limit, published):
    if published:
        return {'data': f'blog list {published} blogs from the db'}
    else:
        return {'data': 'all the blogs from db'}
```

* here without type hints we will not get bool and "false" will also consider as true. and the output will always be `blog list {published} blogs from the db`
* solutions use type hints

```python
@app.get('/blog')
def index(limit: int, published: bool):
    if published:
        return {'data': f'blog list {published} blogs from the db'}
    else:
        return {'data': 'all the blogs from db'}
```

* If we use parameters and the client did not give this. this will produce error

```json
{
  "detail": [
    {
      "type": "missing",
      "loc": [
        "query",
        "limit"
      ],
      "msg": "Field required",
      "input": null
    },
    {
      "type": "missing",
      "loc": [
        "query",
        "published"
      ],
      "msg": "Field required",
      "input": null
    }
  ]
}
```

* Solution = use default values with parameters. `def index(limit: int = 10, published: bool = True):`
* if we dont care about the value client sends we should use optional from typing import Optional.

```python
from typing import Optional

@app.get('/blog')
def index(limit: int, published: bool, sort: Optional[str] = None):
    if published:
        return {'data': f'blog list {published} blogs from the db'}
    else:
        return {'data': 'all the blogs from db'}
```

* Now, the question is how fastAPI identifies the  query parameters and dynamic path values in `path operation function identify`?
* ans =  first check the decorators parameters and rest of them are considered as query parameters.

```python
@app.get('/blog/{id}/comments')
def comments(id: int):
    #return comments of blog with id = id
    return {'data': ['Comment1', 'Comment2']}
```

# Eighth, request body

* How send informations from clients?
* solution = use Pydantic
* import the `Pydantic BaseModel` using `from pydantic import BaseModel`
* then define a class extending this base model. Then we are using this class as a Pydantic model.

```python
from pydantic import BaseModel

class Blog(BaseModel):
   pass

@app.post('/blog')
def create_blog(request: Blog):
    return {'data': f"Blog is created with {request}"}
```

* This will require a body from client side. (will add require body in documentation)

```python
from typing import Optional
from pydantic import BaseModel

class Blog(BaseModel):
    title: str
    body: str
    published: Optional[bool]

@app.post('/blog')
def create_blog(request: Blog):
    return {'data': f"Blog is created wiht {request.title}"}
```

* This will require the title and body from the client.
